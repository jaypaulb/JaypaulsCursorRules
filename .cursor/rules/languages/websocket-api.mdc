---
description: WebSocket and real-time API development standards. Covers connection management, message patterns, reconnection logic, and atomic design structure for WebSocket clients and servers. Apply when working with WebSocket APIs.
globs: *websocket*.py,*websocket*.ts,*websocket*.js,*websocket*.go,*ws*.py,*ws*.ts,*ws*.js,*ws*.go
alwaysApply: false
---

# WebSocket API Development Standards

> **Note**: This rule provides WebSocket-specific patterns. For language-specific patterns, see language rules. For TDD methodology, see `tdd-methodology.mdc`. For atomic design structure, see `code-structure.mdc`.

## WebSocket Overview

### Core Concepts

- **Connection**: Persistent bidirectional connection
- **Messages**: Text or binary messages
- **Events**: Connection, message, error, close events
- **Reconnection**: Automatic reconnection on disconnect
- ****Heartbeat**: Keep-alive mechanism

### Connection Lifecycle

1. **Connect**: Establish WebSocket connection
2. **Authenticate**: Send authentication message (if required)
3. **Subscribe**: Subscribe to channels/topics (if applicable)
4. **Receive**: Handle incoming messages
5. **Send**: Send messages to server
6. **Reconnect**: Handle disconnections and reconnect
7. **Close**: Clean shutdown

## Code Structure (Atomic Design)

Structure WebSocket code following atomic design hierarchy (see `code-structure.mdc` for general principles):

### Atoms (Basic Building Blocks)

- **Message Types**: Message data structures
- **Event Handlers**: Basic event handler functions
- **Connection Utilities**: Connection state management
- **Size**: <100 lines each

### Molecules (Composed Components)

- **Connection Manager**: Manages WebSocket connection lifecycle
- **Message Handler**: Handles incoming/outgoing messages
- **Reconnection Logic**: Handles reconnection
- **Compose atoms**: Import and use message types, handlers
- **Size**: <200 lines each

### Organisms (Complex Modules)

- **WebSocket Client**: Complete WebSocket client
- **WebSocket Server**: Complete WebSocket server
- **Compose molecules**: Import connection manager, message handler
- **Size**: <500 lines

## Connection Management

### Connection Patterns

- Use connection pool for multiple connections
- Handle connection state (connecting, connected, disconnected, reconnecting)
- Implement connection timeout
- Handle connection errors gracefully

### Authentication

- Authenticate after connection established
- Send auth token in initial message or header
- Handle authentication failures
- Re-authenticate on reconnection

## Message Patterns

### Message Format

- **Text Messages**: JSON-encoded strings (most common)
- **Binary Messages**: Binary data (for performance)
- **Message Structure**: `{ type: "message_type", data: {...}, id: "message_id" }`

### Message Types

- **Request/Response**: Request message with response expected
- **Publish/Subscribe**: Publish to channels, subscribe to topics
- **Heartbeat**: Keep-alive messages
- **Error**: Error messages from server

## Reconnection Logic

### Reconnection Strategy

- **Exponential Backoff**: Increase delay between reconnection attempts
- **Max Retries**: Limit number of reconnection attempts
- **Jitter**: Add randomness to prevent thundering herd
- **State Preservation**: Preserve connection state during reconnection

### Reconnection Pattern

```typescript
// TypeScript example pattern
class ReconnectionManager {
  private attempts = 0;
  private maxAttempts = 10;
  private baseDelay = 1000;

  async reconnect(): Promise<void> {
    while (this.attempts < this.maxAttempts) {
      const delay = this.baseDelay * Math.pow(2, this.attempts) + Math.random() * 1000;
      await this.sleep(delay);
      try {
        await this.connect();
        this.attempts = 0;
        return;
      } catch (error) {
        this.attempts++;
      }
    }
    throw new Error('Max reconnection attempts reached');
  }
}
```

## Error Handling

### Error Types

- **Connection Errors**: Network failures, timeouts
- **Authentication Errors**: Invalid credentials
- **Message Errors**: Invalid message format
- **Server Errors**: Server-side errors

### Error Handling Pattern

- Handle errors at connection level
- Handle errors at message level
- Log errors appropriately
- Notify user/application of errors
- Implement retry logic for transient errors

## Testing (TDD)

Follow TDD methodology (see `tdd-methodology.mdc` for core principles):

### TDD Workflow (WebSocket)

1. **Red**: Write failing test first (test connection, message handling)
2. **Green**: Write minimal code to pass
3. **Refactor**: Improve code while keeping tests green

### Test Structure (Atomic Design)

- **Atoms**: Unit tests for message types/handlers - test in isolation
- **Molecules**: Integration tests for connection manager - test with mocked WebSocket
- **Organisms**: System tests for WebSocket client - test with test server

### Test Requirements

- Write tests before implementation (TDD)
- Test coverage >80% (100% for public APIs)
- Mock WebSocket connections for testing
- Test connection lifecycle
- Test message sending/receiving
- Test reconnection logic
- Test error handling
- Use WebSocket testing libraries (language-appropriate)

## Security

- Use WSS (WebSocket Secure) in production
- Validate all incoming messages
- Authenticate connections
- Implement rate limiting
- Sanitize message content
- Never expose sensitive data in messages

## Performance

- Use connection pooling for multiple connections
- Implement message batching when possible
- Use binary messages for large data
- Optimize message serialization/deserialization
- Implement message queuing for high throughput
- Use appropriate buffer sizes

## Documentation

- Document connection lifecycle
- Document message formats
- Document authentication requirements
- Document error conditions
- Provide usage examples
- Document reconnection behavior
