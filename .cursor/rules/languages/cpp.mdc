---
description: C++ development standards. Includes quality gates, code style, project structure, build systems, memory management, testing, and performance. Apply when working with C++ files.
globs: *.cpp,*.hpp,*.h,*.cc,CMakeLists.txt,Makefile,*.cmake
alwaysApply: false
---

# C++ Development Standards

> **Note**: Assumes core rules (command execution, file operations, quality gates, error handling, naming) are already loaded.

## Quality Gates (C++-Specific)
- All code must pass: `clang-format`, `clang-tidy`, `cppcheck`, unit tests
- Test coverage >80% (use `gcov` or `llvm-cov`)
- Documentation for all public APIs
- Use modern C++ standards (C++17 or later preferred)

## Code Style
- Follow Google C++ Style Guide or similar established standard
- Use `clang-format` for consistent formatting
- Use meaningful names for variables, functions, and classes
- Prefer RAII (Resource Acquisition Is Initialization)

## Project Structure (Atomic Design)

Structure C++ code following atomic design hierarchy (see `code-structure.mdc` for general principles):

### Atoms (Basic Building Blocks)
- **Single-purpose classes/utilities**: One class, one function, or one small utility per file
- **Size**: <100 lines per file (ideally <50 lines)
- **Location**: `src/atoms/` with headers in `include/project/atoms/`
- **Examples**:
  ```cpp
  // include/project/atoms/user.hpp - Basic User class
  #pragma once

  namespace project::atoms {
      struct User {
          int id;
          std::string email;
          std::string name;
      };
  }

  // include/project/atoms/validator.hpp - Single-purpose validation
  #pragma once
  #include <string>

  namespace project::atoms {
      bool validateEmail(const std::string& email);
  }
  ```

### Molecules (Composed Components)
- **Compose atoms**: Include and use 2-5 atom headers
- **Size**: <200 lines per file (ideally <150 lines)
- **Location**: `src/molecules/` with headers in `include/project/molecules/`
- **Examples**:
  ```cpp
  // include/project/molecules/user_validator.hpp - Composes atoms
  #pragma once
  #include "project/atoms/user.hpp"
  #include "project/atoms/validator.hpp"

  namespace project::molecules {
      std::pair<bool, std::string> validateUser(const atoms::User& user);
  }
  ```

### Organisms (Complex Modules)
- **Compose molecules/atoms**: Include multiple molecule headers
- **Size**: <500 lines per file (ideally <300 lines)
- **Location**: `src/organisms/` with headers in `include/project/organisms/`
- **Examples**:
  ```cpp
  // include/project/organisms/auth_system.hpp - Complete auth system
  #pragma once
  #include "project/molecules/user_validator.hpp"
  #include "project/atoms/user.hpp"

  namespace project::organisms {
      class AuthSystem {
      public:
          bool authenticate(const atoms::User& user);
      };
  }
  ```

### C++-Specific Patterns
- Use namespaces to organize atoms/molecules/organisms (`project::atoms`, `project::molecules`, etc.)
- Keep header files minimal - forward declarations when possible
- Use `#pragma once` or include guards
- Separate interface (header) from implementation (source)
- Use smart pointers for composition and ownership
- Keep includes minimal - prefer composition over deep nesting
- Use CMake to organize atomic design structure

## Build System Standards
- Use CMake as primary build system
- Support out-of-source builds
- Provide clear build instructions
- Use package managers (Conan, vcpkg) for dependencies
- Support multiple compilers (GCC, Clang, MSVC)

## Memory Management
- Prefer smart pointers over raw pointers
- Use `std::unique_ptr` for exclusive ownership
- Use `std::shared_ptr` for shared ownership (sparingly)
- Use `std::weak_ptr` to break circular references
- Follow RAII principles for resource management

## Error Handling
- Use exceptions for error handling (not error codes)
- Create custom exception types for domain-specific errors
- Use `noexcept` for functions that cannot throw
- Document exception guarantees in function documentation

## Testing (TDD)

Follow TDD methodology (see `tdd-methodology.mdc` for core principles):

### TDD Workflow (C++)
1. **Red**: Write failing test first
   ```cpp
   TEST(ValidatorTest, ValidateEmailReturnsTrueForValidEmail) {
       EXPECT_TRUE(validateEmail("user@example.com"));
   }
   ```
2. **Green**: Write minimal code to pass
3. **Refactor**: Improve code while keeping tests green

### Test Structure (Atomic Design)
- **Atoms**: Unit tests in `tests/atoms/` - test individual classes/functions
- **Molecules**: Integration tests in `tests/molecules/` - test composed components
- **Organisms**: System tests in `tests/organisms/` - test complex modules

### C++ Testing Tools
- Use Google Test or Catch2 for unit testing
- Use test fixtures for common setup
- Mock external dependencies with interfaces or mocking libraries
- Use `gcov` or `llvm-cov` for coverage: `gcov *.gcda`

### Test Requirements
- Write tests before implementation (TDD)
- Test coverage >80% (100% for public APIs)
- Test atoms, molecules, and organisms in isolation
- Write tests for all public APIs
- Test edge cases (null pointers, empty containers, boundary values)
- Use descriptive test names: `TEST(ClassName, BehaviorDescription)`

## Security
- Never commit secrets or API keys
- Validate all inputs and sanitize outputs
- Use secure coding practices to prevent buffer overflows
- Avoid undefined behavior
- Use static analysis tools to catch security issues

## Performance
- Use profiling tools to identify bottlenecks
- Prefer move semantics over copying
- Use `const` and `constexpr` where appropriate
- Consider cache locality in data structure design
- Use benchmarks to measure performance improvements

## Dependencies
- Use package managers (Conan, vcpkg) for dependencies
- Pin dependency versions for reproducible builds
- Keep dependencies minimal and well-justified
- Regular security updates
