---
description: TypeScript development standards. Includes quality gates, atomic design structure, type safety, TDD patterns, and TypeScript-specific best practices. Apply when working with TypeScript files.
globs: *.ts,*.tsx,tsconfig.json,*.d.ts
alwaysApply: false
---

# TypeScript Development Standards

> **Note**: Assumes core rules (command execution, file operations, quality gates, error handling, naming, TDD methodology, code structure) are already loaded.

## Quality Gates

TypeScript-specific quality checks (see `quality-gates.mdc` for universal requirements):
- Use `eslint` with TypeScript plugin for linting
- Use `prettier` for code formatting
- Use `tsc --noEmit` for type checking
- Use `jest` or `vitest` for testing
- All public APIs must have type definitions
- Strict mode enabled in `tsconfig.json`

## Code Structure (Atomic Design)

TypeScript-specific atomic design patterns (see `code-structure.mdc` for complete hierarchy and rules):

### Atoms (Basic Building Blocks)

- **Single-purpose types/utilities**: One type, one utility function, or one small class per file
- **Size**: <100 lines (ideally <50 lines)
- **Location**: `src/atoms/` or `src/types/atoms/`
- **Examples**:

  ```typescript
  // src/atoms/user.ts - Basic User type
  export interface User {
    id: number;
    email: string;
    name: string;
  }

  // src/atoms/validator.ts - Basic validation utility
  export function validateEmail(email: string): boolean {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }
  ```

### Molecules (Composed Components)

- **Compose atoms**: Import and use 2-5 atoms
- **Size**: <200 lines (ideally <150 lines)
- **Location**: `src/molecules/`
- **Examples**:

  ```typescript
  // src/molecules/userValidator.ts - Composes atoms
  import { User } from '../atoms/user';
  import { validateEmail } from '../atoms/validator';

  export function validateUser(user: User): [boolean, string] {
    if (!validateEmail(user.email)) {
      return [false, 'Invalid email'];
    }
    return [true, 'Valid'];
  }
  ```

### Organisms (Complex Modules)

- **Compose molecules/atoms**: Import multiple molecules
- **Size**: <500 lines (ideally <300 lines)
- **Location**: `src/organisms/`
- **Examples**:

  ```typescript
  // src/organisms/authSystem.ts - Complete auth system
  import { validateUser } from '../molecules/userValidator';
  import { User } from '../atoms/user';

  export class AuthSystem {
    async authenticate(user: User): Promise<boolean> {
      const [isValid] = validateUser(user);
      return isValid;
    }
  }
  ```

### TypeScript-Specific Patterns

- Use interfaces for object shapes
- Use types for unions, intersections, and complex types
- Use enums for constants (or const assertions)
- Use generics for reusable components
- Use namespaces sparingly (prefer modules)
- Keep imports minimal - prefer composition over deep nesting

## Type Safety

### Strict Mode

Enable strict mode in `tsconfig.json`:

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true
  }
}
```

### Type Definitions

- All public APIs must have explicit types
- Avoid `any` type (use `unknown` if type is truly unknown)
- Use type guards for runtime type checking
- Use discriminated unions for type-safe state machines
- Export types/interfaces for public APIs

### Type Patterns

```typescript
// Discriminated union
type Result<T> =
  | { success: true; data: T }
  | { success: false; error: string };

// Type guard
function isUser(obj: unknown): obj is User {
  return (
    typeof obj === 'object' &&
    obj !== null &&
    'id' in obj &&
    'email' in obj
  );
}
```

## Code Style

- Follow ESLint TypeScript recommended rules
- Use `camelCase` for variables/functions
- Use `PascalCase` for classes/interfaces/types
- Use `UPPER_SNAKE_CASE` for constants
- Use async/await for asynchronous operations
- Prefer `const` over `let`, avoid `var`

## Documentation

- Use JSDoc comments for public APIs
- Include parameter types and return types in JSDoc
- Document complex type relationships
- Provide usage examples in comments

## Testing (TDD)

TypeScript-specific TDD patterns (see `tdd-methodology.mdc` for core TDD principles):

### TypeScript Testing Tools
- Use `jest` or `vitest` for unit and integration tests
- Use `@testing-library/react` for React component tests (if using React)
- Use `ts-jest` or `tsx` for TypeScript test execution
- Mock external dependencies with `jest.mock()` or `vi.mock()`
- Use `jest --coverage` for coverage reports

### TDD Workflow Example (TypeScript)
```typescript
// Red: Write failing test first
test('validateEmail returns true for valid email', () => {
  expect(validateEmail('user@example.com')).toBe(true);
});

// Green: Write minimal code to pass
// Refactor: Improve while keeping tests green
```

## Dependencies

- Pin dependency versions in `package.json`
- Use `npm audit` or `yarn audit` to check for security vulnerabilities
- Keep dependencies minimal and well-justified
- Use type definitions from `@types/*` packages
- Prefer typed libraries over untyped ones

## Security

TypeScript-specific security patterns (see `security.mdc` for universal security requirements):
- Use `process.env` for environment variables (with type-safe access)
- Use `dotenv` for `.env` file management (never commit `.env`)

## Performance

- Use async/await for I/O operations
- Avoid blocking the event loop
- Use appropriate data structures for performance
- Profile and optimize hot paths
- Use TypeScript's type system to catch performance issues early
