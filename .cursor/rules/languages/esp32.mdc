---
description: ESP32/Espressif development standards for ESP32-S3 hardware. Covers ESP-IDF framework, hardware-specific patterns, FreeRTOS, peripherals, power management, and ESP32-S3 specific features. Apply when working with ESP32/Espressif projects.
globs: *.c,*.h,*.cpp,*.hpp,CMakeLists.txt,*.cmake,sdkconfig,sdkconfig.defaults,partitions.csv,*.ld
alwaysApply: false
---

# ESP32/Espressif Development Standards

> **Note**: Assumes core rules (command execution, file operations, quality gates, error handling, naming, TDD methodology, code structure) are already loaded. For general C++ patterns, see `cpp.mdc`.

## ESP32-S3 Hardware Overview

### Key Hardware Features

- **Dual-core Xtensa LX7 processor** (up to 240 MHz)
- **WiFi 802.11 b/g/n** and **Bluetooth 5.0 (LE)**
- **USB OTG** support (native USB)
- **Single USB port** with mode switching (USB-JTAG or USB-OTG, not both simultaneously)
- **Rich peripherals**: GPIO, I2C, SPI, UART, ADC, DAC, PWM, RMT, I2S, Camera, LCD
- **Low power modes**: Light sleep, Deep sleep, Hibernation
- **PSRAM** support (external or integrated)
- **Flash** storage (typically 4MB+)

### ESP32-S3 Specific Considerations

- Native USB support (no USB-to-Serial chip needed)
- **Single USB port** that can be switched between USB-JTAG and USB-OTG modes
- **Mode switching**: In OTG mode, JTAG is disabled (cannot use UART debugging)
- Enhanced security features
- Better power management than ESP32

## ESP-IDF Framework

### Framework Structure

- **ESP-IDF**: Official Espressif IoT Development Framework
- **FreeRTOS**: Real-time operating system (included)
- **Component-based architecture**: Modular, reusable components
- **CMake build system**: Modern build configuration
- **Partition tables**: Flash memory layout management

### Project Structure

```text
project/
├── main/                    # Main application code
│   ├── CMakeLists.txt      # Main component CMake
│   ├── main.c              # Application entry point
│   └── components/         # Custom components (atoms/molecules/organisms)
├── components/             # Shared components
│   ├── atoms/              # Basic building blocks
│   ├── molecules/          # Composed components
│   └── organisms/          # Complex modules
├── CMakeLists.txt          # Root CMake
├── sdkconfig              # Build configuration
├── sdkconfig.defaults      # Default configuration
└── partitions.csv         # Flash partition table
```

## Code Structure (Atomic Design)

ESP32-specific atomic design patterns (see `code-structure.mdc` for complete hierarchy and rules):

### Atoms (Basic Building Blocks)

- **Single-purpose drivers/peripherals**: One peripheral driver, one utility function per file
- **Size**: <100 lines (ideally <50 lines)
- **Location**: `components/atoms/` or `main/components/atoms/`
- **Examples**:

  ```c
  // components/atoms/gpio_driver/gpio_driver.c - Basic GPIO driver
  #include "driver/gpio.h"
  #include "gpio_driver.h"

  esp_err_t gpio_driver_init(gpio_num_t pin, gpio_mode_t mode) {
      gpio_config_t io_conf = {
          .pin_bit_mask = (1ULL << pin),
          .mode = mode,
          .pull_up_en = GPIO_PULLUP_DISABLE,
          .pull_down_en = GPIO_PULLDOWN_DISABLE,
          .intr_type = GPIO_INTR_DISABLE
      };
      return gpio_config(&io_conf);
  }
  ```

### Molecules (Composed Components)

- **Compose atoms**: Import and use 2-5 atom drivers/utilities
- **Size**: <200 lines (ideally <150 lines)
- **Location**: `components/molecules/`
- **Examples**:

  ```c
  // components/molecules/sensor_reader/sensor_reader.c - Composes atoms
  #include "gpio_driver.h"
  #include "i2c_driver.h"
  #include "sensor_reader.h"

  esp_err_t sensor_reader_init(sensor_reader_t *reader) {
      ESP_ERROR_CHECK(gpio_driver_init(reader->gpio_pin, GPIO_MODE_OUTPUT));
      ESP_ERROR_CHECK(i2c_driver_init(reader->i2c_port));
      return ESP_OK;
  }
  ```

### Organisms (Complex Modules)

- **Compose molecules/atoms**: Import multiple molecules
- **Size**: <500 lines (ideally <300 lines)
- **Location**: `components/organisms/`
- **Examples**:

  ```c
  // components/organisms/sensor_system/sensor_system.c - Complete sensor system
  #include "sensor_reader.h"
  #include "data_logger.h"
  #include "wifi_manager.h"

  esp_err_t sensor_system_init(sensor_system_t *system) {
      ESP_ERROR_CHECK(sensor_reader_init(&system->reader));
      ESP_ERROR_CHECK(data_logger_init(&system->logger));
      ESP_ERROR_CHECK(wifi_manager_init(&system->wifi));
      return ESP_OK;
  }
  ```

### ESP32-S3 Specific Patterns

- Use **components** for modularity (ESP-IDF component system)
- Use **FreeRTOS tasks** for concurrent operations
- Use **event loops** for asynchronous operations
- Use **partitions** for flash memory management
- Keep components small and focused (atomic design)

## FreeRTOS Integration

### Task Management

- Use FreeRTOS tasks for concurrent operations
- Keep tasks small and focused (atomic design)
- Use task priorities appropriately
- Use queues for inter-task communication
- Use semaphores/mutexes for synchronization

### Task Patterns

```c
// Create task
xTaskCreate(task_function, "task_name", 4096, NULL, 5, NULL);

// Task function (atom/molecule/organism)
void task_function(void *pvParameters) {
    // Task implementation
    while (1) {
        // Task logic
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}
```

## Hardware Peripherals

### GPIO

- Use `driver/gpio.h` for GPIO operations
- Configure GPIO before use
- Use interrupt handlers for GPIO events
- Follow ESP32-S3 GPIO matrix (some pins have restrictions)

### I2C/SPI/UART

- Use `driver/i2c_master.h`, `driver/spi_master.h`, `driver/uart.h`
- Configure bus parameters (speed, pins, etc.)
- Use transactions for data transfer
- Handle errors appropriately

### ADC/DAC

- Use `driver/adc.h`, `driver/dac.h` for analog I/O
- Calibrate ADC for accurate readings
- Use attenuation settings appropriately
- Consider noise and filtering

### PWM

- Use `driver/ledc.h` for PWM (LED controller)
- Configure frequency and resolution
- Use appropriate channels
- Consider duty cycle limits

## Power Management

### Power Modes

- **Active**: Full operation (highest power)
- **Light Sleep**: CPU stopped, peripherals can wake
- **Deep Sleep**: Most peripherals off, RTC memory preserved
- **Hibernation**: Lowest power, only RTC memory preserved

### Power Management Patterns

```c
// Enter light sleep
esp_sleep_enable_timer_wakeup(10000000); // 10 seconds
esp_light_sleep_start();

// Enter deep sleep
esp_sleep_enable_timer_wakeup(10000000);
esp_deep_sleep_start();
```

## WiFi and Bluetooth

### WiFi

- Use `esp_wifi.h` for WiFi operations
- Configure as station, AP, or both
- Handle connection events
- Use event handlers for WiFi events

### Bluetooth

- Use `esp_bt.h` for Bluetooth Classic
- Use `esp_ble.h` for Bluetooth Low Energy
- Configure GATT services/characteristics (BLE)
- Handle pairing and security

## USB (ESP32-S3 Specific)

### USB Support

- **Single USB port** with mode switching capability
- **USB-JTAG mode**: For debugging and programming (default)
- **USB-OTG mode**: For USB device/host functionality
- **Important**: Cannot use both modes simultaneously - switching to OTG disables JTAG/UART

### USB Mode Switching

- Configure USB mode in `sdkconfig` or via menuconfig
- **USB-JTAG mode** (default): Enables debugging and UART communication
- **USB-OTG mode**: Enables USB device/host functionality, but disables JTAG/UART
- Choose mode based on development needs (debugging vs USB functionality)

### USB Patterns

```c
// USB-JTAG mode (default) - for debugging
// Configured automatically in ESP-IDF
// Allows UART communication via USB

// USB-OTG mode - for USB device/host
// Configure in sdkconfig: CONFIG_USB_OTG_SUPPORTED=y
// Note: JTAG/UART disabled in OTG mode
#include "driver/usb_serial_jtag.h"
usb_serial_jtag_driver_config_t usb_serial_config = USB_SERIAL_JTAG_DRIVER_CONFIG_DEFAULT();
usb_serial_jtag_driver_install(&usb_serial_config);
```

## Memory Management

### Memory Types

- **IRAM**: Instruction RAM (fast, limited)
- **DRAM**: Data RAM (general purpose)
- **PSRAM**: External PSRAM (if available)
- **Flash**: Non-volatile storage

### Memory Considerations

- Use `heap_caps_malloc()` for specific memory types
- Monitor heap usage with `esp_get_free_heap_size()`
- Use PSRAM for large buffers (if available)
- Consider memory fragmentation

## Partition Tables

### Flash Layout

- **Partition table**: Defines flash memory layout
- **Partitions**: Bootloader, app, OTA, NVS, SPIFFS, etc.
- **OTA support**: Over-the-air updates
- **NVS**: Non-volatile storage

### Partition Configuration

```csv
# partitions.csv
# Name,   Type, SubType, Offset,  Size, Flags
nvs,      data, nvs,     0x9000,  0x6000,
phy_init, data, phy,     0xf000,  0x1000,
factory,  app,  factory, 0x10000, 1M,
```

## Error Handling

ESP32-specific error handling patterns (see `error-handling.mdc` for universal patterns):

### ESP-IDF Error Codes

- Use `esp_err_t` for error codes
- Use `ESP_ERROR_CHECK()` for critical errors (aborts on error)
- Use `ESP_LOGE()`, `ESP_LOGW()`, `ESP_LOGI()`, `ESP_LOGD()` for logging
- Handle errors appropriately (don't ignore)

### Error Handling Pattern

```c
esp_err_t ret = gpio_config(&io_conf);
if (ret != ESP_OK) {
    ESP_LOGE(TAG, "GPIO config failed: %s", esp_err_to_name(ret));
    return ret;
}
```

## Testing (TDD)

ESP32-specific TDD patterns (see `tdd-methodology.mdc` for core TDD principles):

### ESP32 Testing Tools

- Use **Unity** test framework (included in ESP-IDF)
- Use **CMock** for mocking (included in ESP-IDF)
- Use **ESP-IDF test runner** for component tests
- Use hardware-in-the-loop testing for hardware-dependent code

### TDD Workflow Example (ESP32)

```c
// Red: Write failing test first
TEST_CASE("gpio_driver_init_returns_ok_for_valid_config", "[gpio]")
{
    esp_err_t ret = gpio_driver_init(GPIO_NUM_2, GPIO_MODE_OUTPUT);
    TEST_ASSERT_EQUAL(ESP_OK, ret);
}

// Green: Write minimal code to pass
// Refactor: Improve while keeping tests green
```

### Test Structure (Atomic Design)

- **Atoms**: Unit tests for individual drivers/utilities
- **Molecules**: Integration tests for composed components
- **Organisms**: System tests for complex modules
- **Hardware tests**: Hardware-in-the-loop tests for hardware-dependent code

## Build System (CMake)

### Component Configuration

```cmake
# components/atoms/gpio_driver/CMakeLists.txt
idf_component_register(
    SRCS "gpio_driver.c"
    INCLUDE_DIRS "."
    PRIV_REQUIRES driver
)
```

### Project Configuration

- Use `sdkconfig` for build configuration
- Use `sdkconfig.defaults` for default settings
- Configure via `idf.py menuconfig`
- Document configuration changes

## Debugging

### Debugging Tools

- **USB-JTAG**: Native debugging support (ESP32-S3)
- **GDB**: Debugger support via USB-JTAG
- **ESP-IDF monitor**: Serial monitor (`idf.py monitor`)
- **Core dumps**: Crash analysis
- **Logging**: ESP-IDF logging system

### Debugging Patterns

```c
// Use ESP-IDF logging
ESP_LOGI(TAG, "Initializing GPIO");
ESP_LOGE(TAG, "Error: %s", esp_err_to_name(ret));
ESP_LOGW(TAG, "Warning: Low memory");
ESP_LOGD(TAG, "Debug: Variable = %d", value);
```

## Security

ESP32-specific security patterns (see `security.mdc` for universal security requirements):

### ESP32-S3 Security Features

- **Secure Boot**: Verify firmware integrity
- **Flash Encryption**: Encrypt flash contents
- **NVS Encryption**: Encrypt NVS data
- **Hardware Security**: Hardware-based security features

### Security Best Practices

- Enable secure boot for production
- Use flash encryption for sensitive data
- Use NVS encryption for credentials
- Never hardcode secrets (use NVS or secure storage)

## Performance

### Performance Considerations

- Use **IRAM** for time-critical code
- Use **DMA** for high-speed transfers
- Use **FreeRTOS tasks** for concurrent operations
- Profile with ESP-IDF profiling tools
- Monitor heap usage

### Optimization Patterns

```c
// Place function in IRAM (fast execution)
IRAM_ATTR void time_critical_function(void) {
    // Time-critical code
}

// Use DMA for SPI transfers
spi_device_transmit(spi_device_handle_t handle, spi_transaction_t *trans);
```

## Documentation

- Document all public APIs
- Include hardware pin configurations
- Document power consumption considerations
- Include timing requirements
- Document memory usage

## Dependencies

- Use ESP-IDF components via `CMakeLists.txt`
- Pin ESP-IDF version in `idf_component.yml`
- Keep dependencies minimal
- Use ESP-IDF component registry when possible
